// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

'use strict';

var assert = require('assert');
var globalTimers = require('timers');

module.exports = ObjectPool;

var DEFAULT_MAX_SIZE = 1000;

function noop() {}

function ObjectPool(options) {
    assert(typeof options === 'object', 'expected options object');

    this.Type = options.Type;
    assert(typeof this.Type === 'function', 'expected options.Type to be constructor function');
    assert(typeof this.Type.prototype.reset === 'function', 'expected options.Type to have reset method');
    assert(typeof this.Type.prototype.clear === 'function', 'expected options.Type to have clear method');

    this.maxSize = options.maxSize || DEFAULT_MAX_SIZE;
    assert(typeof this.maxSize === 'number', 'expected options.maxSize to be number');

    this.name = options.name || this.Type.name;
    assert(typeof this.name === 'string', 'expected options.name to be string');

    this.freeList = [];
    this.outstanding = 0;

    this.statTags = { 'pool-name': this.name };

    // only used in debug mode
    this.outstandingList = [];
}

ObjectPool.reportInterval = null;
ObjectPool.timers = null;
ObjectPool.pools = [];
ObjectPool.timer = null;
ObjectPool.refs = 0;
ObjectPool.debug = false;

ObjectPool.setup = function setup(options) {
    var pool = new ObjectPool(options);
    options.Type.alloc = alloc;

    options.Type.prototype.free = function freeThisObj() {
        pool.free(this);
    };

    ObjectPool.pools.push(pool);

    return pool;

    function alloc() {
        return pool.get();
    }
};

ObjectPool.bootstrap = function bootstrap(options) {
    if (ObjectPool.refs >= 1) {
        ObjectPool.refs += 1;
        return;
    }

    ObjectPool.refs += 1;

    assert(typeof options === 'object', 'expected options object');

    ObjectPool.statReceiver = options.statReceiver || noop;
    assert(
        typeof ObjectPool.statReceiver === 'function',
        'expected options.statReceier to be function'
    );

    ObjectPool.reportInterval = options.reportInterval || -1;
    assert(
        typeof ObjectPool.reportInterval === 'number',
        'expected options.reportInterval to be number'
    );

    ObjectPool.timers = options.timers || globalTimers;
    assert(
        typeof ObjectPool.timers === 'object' &&
        typeof ObjectPool.timers.setTimeout === 'function',
        'expected options.timers to be timers object'
    );

    // istanbul ignore next
    if (typeof options.debug === 'boolean') {
        ObjectPool.debug = options.debug;
    }

    if (ObjectPool.reportInterval !== -1) {
        ObjectPool.timer = ObjectPool.timers.setTimeout(
            ObjectPool.reportStats,
            ObjectPool.reportInterval
        );
        ObjectPool.timer.unref();
    }
};

ObjectPool.unref = function unref() {
    ObjectPool.refs = Math.max(0, ObjectPool.refs - 1);
    if (ObjectPool.refs === 0) {
        ObjectPool.timers.clearTimeout(ObjectPool.timer);
        ObjectPool.timer = null;
    }
};

ObjectPool.reportStats = function reportStats() {
    // Iterate over pools, report their current size

    var i;
    for (i = 0; i < ObjectPool.pools.length; i++) {
        ObjectPool.pools[i].reportStats(ObjectPool.statReceiver);
    }

    ObjectPool.timer = ObjectPool.timers.setTimeout(
        ObjectPool.reportStats,
        ObjectPool.reportInterval
    );
    ObjectPool.timer.unref();
};

ObjectPool.prototype.reportStats = function reportStats(statReceiver) {
    statReceiver(
        'gauge',
        'object-pool.free',
        this.freeList.length,
        this.statTags
    );

    statReceiver(
        'gauge',
        'object-pool.outstanding',
        this.outstanding,
        this.statTags
    );
};

ObjectPool.prototype.get = function get() {
    var inst;
    this.outstanding += 1;
    if (this.freeList.length) {
        inst = this.freeList.pop();
        assert(inst._objectPoolIsFreed, 'instance retreived from pool is free');
        inst._objectPoolIsFreed = false;

        // istanbul ignore next
        if (ObjectPool.debug) {
            this.outstandingList.push(inst);
        }

        return inst;
    } else {
        inst = new this.Type();
        inst._objectPoolIsFreed = false;

        // istanbul ignore next
        if (ObjectPool.debug) {
            this.outstandingList.push(inst);
        }

        return inst;
    }
};

ObjectPool.prototype.free = function free(inst) {
    assert(!inst._objectPoolIsFreed, 'object pool double free');
    inst._objectPoolIsFreed = true;

    inst.clear();
    if (this.outstanding <= this.maxSize) {
        this.freeList.push(inst);
    }
    this.outstanding -= 1;

    var i;
    // istanbul ignore next
    if (ObjectPool.debug) {
        for (i = 0; i < this.outstandingList.length; i++) {
            if (this.outstandingList[i] === inst) {
                this.outstandingList.splice(i, 1);
                return;
            }
        }
    }
};
